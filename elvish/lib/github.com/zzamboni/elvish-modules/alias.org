#+title: Aliases for Elvish
#+author: Diego Zamboni
#+email: diego@zzamboni.org

#+name: module-summary
Implementation of aliases for [[http://elvish.io][Elvish]].

This file is written in [[https://leanpub.com/lit-config][literate programming style]], to make it easy to explain. See [[alias.elv][alias.elv]] for the generated file.

* Table of Contents :TOC:noexport:
- [[#usage][Usage]]
- [[#implementation][Implementation]]
  - [[#loading-libraries][Loading libraries]]
  - [[#configuration][Configuration]]
  - [[#creating-aliases][Creating aliases]]
  - [[#listing-aliases][Listing aliases]]
  - [[#removing-aliases][Removing aliases]]
  - [[#load-time-initialization][Load-time initialization]]

* Usage

Install the =elvish-modules= package using [[https://elvish.io/ref/epm.html][epm]]:

#+begin_src elvish
use epm
epm:install github.com/zzamboni/elvish-modules
#+end_src

In your =rc.elv=, load this module:

#+begin_src elvish
use github.com/zzamboni/elvish-modules/alias
#+end_src

To define an alias:

#+begin_src elvish
alias:new alias command
#+end_src

Aliases are automatically stored persistently. Each alias is stored in a separate file under =$alias:dir= (=~/.elvish/aliases/= by default).

Note that due to Elvish's scoping rules, if you want to use a module from your alias, you need to load the module as well by specifying the =&use= option when defining the alias, which receives a list of module names to load, like this:

#+begin_src elvish
alias:new cd &use=[github.com/zzamboni/elvish-modules/dir] dir:cd
#+end_src

You can also specify the =use= command as part of the alias:

#+begin_src elvish
alias:new cd "use github.com/zzamboni/elvish-modules/dir; dir:cd"
#+end_src

Normally, any arguments you specify to the alias are appended at the end of its definition. However, you can specify where they should appear by inserting the string ={}= (in Elvish you have to quote it like this ='{}'= ), then the arguments are inserted at that place in the command:

#+begin_src elvish
alias:new fdirs find '{}' -name foo
#+end_src

You can configure the string to use for the argument placeholder by setting the value of =$aliases:arg-replacer=. For example:

#+begin_src elvish
alias:arg-replacer = '@@@'
alias:new fdirs find @@@ -name foo
#+end_src

You can also use =alias:bash-alias= to use the bash syntax =alias=command= for defining aliases.

To list existing aliases:

#+begin_src elvish
alias:list
#+end_src

To remove an alias:

#+begin_src elvish
alias:rm alias
#+end_src

The alias is not removed from the current session, it will take effect in new sessions, or you can remove it by hand by running =del $aliasname~=.

* Implementation
:PROPERTIES:
:header-args:elvish: :tangle (concat (file-name-sans-extension (buffer-file-name)) ".elv")
:header-args: :mkdirp yes :comments no
:END:

#+begin_src elvish :exports none
# DO NOT EDIT THIS FILE DIRECTLY
# This is a file generated from a literate programing source file located at
# https://github.com/zzamboni/elvish-modules/blob/master/alias.org.
# You should make any changes there and regenerate it from Emacs org-mode using C-c C-v t
#+end_src

** Loading libraries

#+begin_src elvish
use re
use str
#+end_src

** Configuration

The =alias:dir= variable determines where the alias files will be saved.

#+begin_src elvish
dir = ~/.elvish/aliases
#+end_src

The =alias:arg-replacer= variable contains the string that will be used to indicate where the arguments will be inserted in the alias expansion.

#+begin_src elvish
arg-replacer = '{}'
#+end_src

** Creating aliases

Aliases are defined as functions with the corresponding name, which execute the body provided as the alias definition, always allowing optional parameters to be provided to the alias, and which are added at the end of the alias definition. After writing the files under =$alias:dir=, we load them and store the function pointers in the =$alias:aliases= map.

The =$alias:aliases= map is where all the alias definitions are loaded, indexed by name.

#+begin_src elvish
aliases = [&]
#+end_src

The =-load-alias= function receives the name of the alias and the file in which it is stored. It reads the file with =eval= and stores a pointer to the function in =$alias:aliases=. The alias files contain standalone function definitions and can also be =-source='d directly from the prompt to load the alias in the current interactive session.

#+begin_src elvish
fn -load-alias [name file]{
  body = $nil
  eval (slurp < $file)"; body = $"$name"~"
  aliases[$name] = $body
  edit:add-var $name"~" $body
}
#+end_src

The =alias:def= function creates a new alias. It stores the corresponding alias file, but does not load the alias in memory, since this is not possibe due to Elvish's scoping rules. The =&use= option can be used to specify a list of modules to load within the alias function (you can also specify the =use= command by hand as part of the alias). By default, an alias will add any arguments it receives to the end of its definition. But if the string =$arg-replacer= (default ={}=) appears in the definition (it has to appear as a space-separated word), then the arguments are inserted in its place, and NOT added at the end.

#+begin_src elvish
fn def [&verbose=$false &use=[] name @cmd]{
  file = $dir/$name.elv
  use-statements = [(each [m]{ put "use "$m";" } $use)]
  echo "#alias:new" $name (if (not-eq $use []) { put "&use="(to-string $use) }) $@cmd > $file
  args-at-end = '$@_args'
  new-cmd = [
    (each [e]{
        if (eq $e $arg-replacer) {
          put '$@_args'
          args-at-end = ''
        } else {
          put $e
        }
    } $cmd)
  ]
  echo 'fn '$name' [@_args]{' $@use-statements $@new-cmd $args-at-end '}' >> $file
  -load-alias $name $file
  if $verbose {
    echo (styled "Alias "$name" defined (will take effect on new sessions, or when you run '-source "$file"')." green)
  }
}
#+end_src

=alias:new= is equivalent to =alias:def=.

#+begin_src elvish
new~ = $def~
#+end_src

The =alias:bash-alias= command simply splits the arguments on the first equals sign, and calls =alias:def= with the two pieces.

#+begin_src elvish
fn bash-alias [@args]{
  line = $@args
  name cmd = (str:split &max=2 '=' $line)
  def $name $cmd
}
#+end_src

** Listing aliases

To list aliases, we grep the aliases directory for the corresponding definition files. Each file has a marker at the beginning which includes the alias definition command. =alias:list= and =alias:ls= are equivalent.

#+begin_src elvish
fn list {
  _ = ?(grep -h '^#alias:new ' $dir/*.elv | sed 's/^#//')
}

ls~ = $list~ # ls is an alias for list
#+end_src

** Removing aliases

Removing an alias is achieved by removing its definition file. =alias:rm= and =alias:undef= are equivalent.

Alias removals do not take place in the current session, unless you manually remove them with the =del= command.

#+begin_src elvish
fn undef [name]{
  file = $dir/$name.elv
  if ?(test -f $file) {
    # Remove the definition file
    rm $file
    echo (styled "Alias "$name" removed (will take effect on new sessions, or when you run 'del "$name"~')." green)
  } else {
    echo (styled "Alias "$name" does not exist." red)
  }
}

rm~ = $undef~ # rm is an alias for undef
#+end_src

** Load-time initialization

The =init= function is run automatically when the module is loaded. It creates the alias directory if needed, and loads all the existing alias files. Note that this does not export the functions, you need to use =alias:export= from your =rc.elv= for that.

#+begin_src elvish
fn init {
  if (not ?(test -d $dir)) {
    mkdir -p $dir
  }

  for file [(_ = ?(put $dir/*.elv))] {
    content = (cat $file | slurp)
    if (re:match '^#alias:new ' $content) {
      name = (re:find '^#alias:new (\S+)\s+(.*)\n' $content)[groups][1][text]
      -load-alias $name $file
    }
  }
}

init
#+end_src
